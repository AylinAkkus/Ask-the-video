/**
 * YouTube Transcript Extraction Module
 * Uses youtube-caption-extractor for reliable transcript fetching
 */

import { getSubtitles } from 'youtube-caption-extractor'

export interface TranscriptSegment {
  text: string;
  start: number; // Start time in seconds
  duration: number; // Duration in seconds
}

export interface CaptionTrack {
  baseUrl: string;
  name: { simpleText: string };
  vssId: string;
  languageCode: string;
  kind?: string; // "asr" for auto-generated
  isTranslatable: boolean;
}

export interface VideoMetadata {
  title: string;
  channelName: string;
  channelId?: string;
  description?: string;
  uploadDate?: string;
  viewCount?: string;
  likeCount?: string;
  duration?: string;
  videoThumbnail?: string;
}

export interface TranscriptResult {
  success: boolean;
  transcript?: TranscriptSegment[];
  videoId?: string;
  videoTitle?: string;
  videoThumbnail?: string;
  metadata?: VideoMetadata;
  language?: string;
  isAutoGenerated?: boolean;
  error?: string;
}

/**
 * Extract ytInitialPlayerResponse from the YouTube player API
 */
export function extractYouTubePlayerResponse(): any | null {
  try {
    // Method 1: Use the player API (most reliable)
    const player = document.querySelector('#movie_player') as any;
    
    if (player && typeof player.getPlayerResponse === 'function') {
      try {
        const response = player.getPlayerResponse();
        if (response) {
          console.log('âœ… Got player response from player API');
          return response;
        }
      } catch (e) {
        console.warn('Failed to get player response from API:', e);
      }
    }
    
    // Method 2: Look for ytInitialPlayerResponse in script tags (fallback)
    const scripts = document.querySelectorAll('script');
    
    for (const script of scripts) {
      const content = script.textContent || '';
      
      // Look for ytInitialPlayerResponse variable declaration
      const match = content.match(/var ytInitialPlayerResponse\s*=\s*({.+?});/s);
      if (match) {
        try {
          return JSON.parse(match[1]);
        } catch (e) {
          console.warn('Failed to parse ytInitialPlayerResponse from script tag:', e);
        }
      }
    }

    // Method 3: Check if it's available on window object (fallback)
    if ((window as any).ytInitialPlayerResponse) {
      return (window as any).ytInitialPlayerResponse;
    }

    console.warn('Could not find YouTube player response data');
    return null;
  } catch (error) {
    console.error('Error extracting YouTube player response:', error);
    return null;
  }
}

/**
 * Get caption tracks from player response
 */
export function getCaptionTracks(playerResponse: any): CaptionTrack[] {
  try {
    const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    
    if (!captions || !Array.isArray(captions)) {
      return [];
    }

    return captions;
  } catch (error) {
    console.error('Error getting caption tracks:', error);
    return [];
  }
}

/**
 * Select the best caption track
 * Prefers: English manual > other manual > English auto > other auto
 */
export function selectBestTrack(tracks: CaptionTrack[]): CaptionTrack | null {
  if (tracks.length === 0) {
    return null;
  }

  // Separate manual and auto-generated tracks
  const manualTracks = tracks.filter(t => t.kind !== 'asr');
  const autoTracks = tracks.filter(t => t.kind === 'asr');

  // Try to find English manual track first
  const englishManual = manualTracks.find(t => t.languageCode.startsWith('en'));
  if (englishManual) {
    return englishManual;
  }

  // If no English manual, take any manual track
  if (manualTracks.length > 0) {
    return manualTracks[0];
  }

  // Fall back to English auto-generated
  const englishAuto = autoTracks.find(t => t.languageCode.startsWith('en'));
  if (englishAuto) {
    return englishAuto;
  }

  // Last resort: any auto-generated track
  if (autoTracks.length > 0) {
    return autoTracks[0];
  }

  // Fallback to first track
  return tracks[0];
}

/**
 * Try to fetch transcript via background script (has better permissions)
 */
async function fetchTranscriptViaPlayer(videoId: string, track: CaptionTrack): Promise<TranscriptSegment[]> {
  console.log('ðŸ”„ Requesting transcript fetch from background script...');
  
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Background fetch timeout'));
    }, 10000);

    chrome.runtime.sendMessage(
      {
        type: 'FETCH_TRANSCRIPT',
        payload: { url: track.baseUrl }
      },
      (response) => {
        clearTimeout(timeout);
        
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
          return;
        }
        
        if (response && response.success) {
          try {
            const data = JSON.parse(response.data);
            const segments = parseJSON3Format(data);
            resolve(segments);
          } catch (e) {
            reject(new Error(`Failed to parse transcript: ${e}`));
          }
        } else {
          reject(new Error(response?.error || 'Background fetch failed'));
        }
      }
    );
  });
}

/**
 * Fetch transcript from YouTube using the track's baseUrl
 * Uses XMLHttpRequest for better compatibility
 */
export async function fetchTranscript(baseUrl: string): Promise<TranscriptSegment[]> {
  return new Promise((resolve, reject) => {
    try {
      // Decode HTML entities in the URL
      const decodedUrl = baseUrl.replace(/&amp;/g, '&');
      
      console.log('ðŸ“¥ Original baseUrl:', decodedUrl.substring(0, 200));
      
      // First, try with fmt=json3
      let url = decodedUrl;
      
      // Check if fmt parameter exists
      if (url.includes('fmt=')) {
        // Replace existing fmt with json3
        url = url.replace(/fmt=[^&]*/, 'fmt=json3');
        console.log('ðŸ“ Replaced existing fmt parameter with json3');
      } else {
        // Add fmt=json3
        url = url.includes('?') ? `${url}&fmt=json3` : `${url}?fmt=json3`;
        console.log('ðŸ“ Added fmt=json3 parameter');
      }

      console.log('ðŸ“¥ Fetching from:', url.substring(0, 200));

      const xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'text';
      
      xhr.onload = function() {
        console.log('ðŸ“Š XHR status:', xhr.status, xhr.statusText);
        console.log('ðŸ“Š Response headers:', xhr.getAllResponseHeaders());
        console.log('ðŸ“ Response length:', xhr.responseText?.length || 0);
        
        if (xhr.status >= 200 && xhr.status < 300) {
          const text = xhr.responseText;
          
          if (!text || text.trim().length === 0) {
            console.error('âŒ Empty response! Trying without fmt parameter...');
            // Try again without modifying the URL
            fetchTranscriptDirect(decodedUrl).then(resolve).catch(reject);
            return;
          }

          console.log('ðŸ“ Response preview:', text.substring(0, 300));

          // Check if it's HTML error page
          if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
            reject(new Error('Received HTML error page instead of transcript data'));
            return;
          }

          // Parse JSON
          try {
            const data = JSON.parse(text);
            const segments = parseJSON3Format(data);
            resolve(segments);
          } catch (e) {
            console.error('Failed to parse JSON:', e, 'Response:', text.substring(0, 500));
            reject(new Error(`Invalid JSON response: ${e}`));
          }
        } else {
          reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
        }
      };
      
      xhr.onerror = function() {
        console.error('âŒ XHR error');
        reject(new Error('Network error fetching transcript'));
      };
      
      xhr.send();
    } catch (error) {
      console.error('Error setting up transcript fetch:', error);
      reject(error);
    }
  });
}

/**
 * Try fetching transcript directly without modifying URL
 */
function fetchTranscriptDirect(url: string): Promise<TranscriptSegment[]> {
  return new Promise((resolve, reject) => {
    console.log('ðŸ”„ Attempting direct fetch without modifications...');
    
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'text';
    
    xhr.onload = function() {
      console.log('ðŸ“Š Direct fetch status:', xhr.status);
      console.log('ðŸ“ Direct fetch response length:', xhr.responseText?.length || 0);
      
      if (xhr.status >= 200 && xhr.status < 300) {
        const text = xhr.responseText;
        
        if (!text || text.trim().length === 0) {
          reject(new Error('Empty response even with unmodified URL'));
          return;
        }

        console.log('ðŸ“ Direct response preview:', text.substring(0, 300));
        
        // Try parsing as XML (VTT/SRT format) or JSON
        try {
          // First try JSON
          const data = JSON.parse(text);
          const segments = parseJSON3Format(data);
          resolve(segments);
        } catch (jsonError) {
          // If not JSON, might be XML or other format
          console.log('Not JSON format, trying to parse as XML/text...');
          reject(new Error('Non-JSON format not yet supported'));
        }
      } else {
        reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
      }
    };
    
    xhr.onerror = function() {
      reject(new Error('Network error on direct fetch'));
    };
    
    xhr.send();
  });
}

/**
 * Parse JSON3 format transcript data
 */
export function parseJSON3Format(data: any): TranscriptSegment[] {
  try {
    if (!data.events || !Array.isArray(data.events)) {
      throw new Error('Invalid transcript format: missing events array');
    }

    const segments: TranscriptSegment[] = [];

    for (const event of data.events) {
      // Each event may have segments (segs) which contain the actual text
      if (event.segs && Array.isArray(event.segs)) {
        const text = event.segs
          .map((seg: any) => seg.utf8 || '')
          .join('')
          .replace(/\n/g, ' ')
          .trim();

        if (text && event.tStartMs !== undefined) {
          segments.push({
            text,
            start: event.tStartMs / 1000, // Convert milliseconds to seconds
            duration: (event.dDurationMs || 0) / 1000,
          });
        }
      }
    }

    return segments;
  } catch (error) {
    console.error('Error parsing JSON3 format:', error);
    throw error;
  }
}

/**
 * Get video ID from current URL
 */
export function getVideoIdFromUrl(): string | null {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('v');
}

/**
 * Extract video metadata from YouTube page
 */
export function extractVideoMetadata(): VideoMetadata | null {
  try {
    // Try to get from player response first
    const playerResponse = extractYouTubePlayerResponse();
    
    if (playerResponse?.videoDetails) {
      const details = playerResponse.videoDetails;
      
      const metadata = {
        title: details.title || 'Unknown Title',
        channelName: details.author || 'Unknown Channel',
        channelId: details.channelId,
        description: details.shortDescription || '',
        viewCount: details.viewCount || '0',
        duration: details.lengthSeconds ? formatDuration(parseInt(details.lengthSeconds)) : undefined,
        videoThumbnail: details.thumbnail?.thumbnails?.[0]?.url,
      };
      
      console.log('ðŸ“Š Extracted metadata from playerResponse:', {
        title: metadata.title,
        channelName: metadata.channelName,
        videoId: details.videoId
      });
      
      return metadata;
    }
    
    // Fallback: Try to extract from page elements
    console.log('âš ï¸ PlayerResponse not available, falling back to DOM extraction');
    const titleElement = document.querySelector('h1.ytd-video-primary-info-renderer yt-formatted-string, h1.ytd-watch-metadata yt-formatted-string');
    const channelElement = document.querySelector('ytd-channel-name a, #channel-name a');
    const descriptionElement = document.querySelector('ytd-expandable-video-description-body-renderer, #description-inner');
    
    return {
      title: titleElement?.textContent?.trim() || 'Unknown Title',
      channelName: channelElement?.textContent?.trim() || 'Unknown Channel',
      description: descriptionElement?.textContent?.trim() || '',
    };
  } catch (error) {
    console.error('Error extracting video metadata:', error);
    return null;
  }
}

/**
 * Format duration in seconds to human-readable format
 */
function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Main function to extract transcript for current YouTube video
 * Uses youtube-caption-extractor library for reliable fetching
 */
export async function extractVideoTranscript(): Promise<TranscriptResult> {
  try {
    const videoId = getVideoIdFromUrl();
    
    if (!videoId) {
      return {
        success: false,
        error: 'No video ID found in URL',
      };
    }

    console.log('ðŸŽ¬ Extracting transcript for video:', videoId);

    // Use youtube-caption-extractor library
    const subtitles = await getSubtitles({ videoID: videoId, lang: 'en' });
    
    if (!subtitles || subtitles.length === 0) {
      return {
        success: false,
        error: 'No captions available for this video',
      };
    }

    console.log('âœ… Transcript fetched:', subtitles.length, 'segments');

    // Convert to our TranscriptSegment format
    const transcript: TranscriptSegment[] = subtitles.map((sub: any) => ({
      text: sub.text,
      start: sub.start,
      duration: sub.dur || 0,
    }));

    // Extract video metadata
    const metadata = extractVideoMetadata();
    console.log('ðŸ“Š Final metadata for video', videoId, ':', {
      title: metadata?.title,
      channelName: metadata?.channelName,
      description: metadata?.description?.substring(0, 50) + '...',
    });

    return {
      success: true,
      transcript,
      videoId,
      videoTitle: metadata?.title || 'Unknown Video',
      videoThumbnail: metadata?.videoThumbnail,
      metadata,
      language: 'en',
      isAutoGenerated: true, // Library doesn't distinguish, assume auto-generated
    };
  } catch (error) {
    console.error('âŒ Error extracting video transcript:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
}

/**
 * Format timestamp in seconds to MM:SS or HH:MM:SS format
 */
export function formatTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

